package refind

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/jmylchreest/refind-btrfs-snapshots/internal/btrfs"
	"github.com/jmylchreest/refind-btrfs-snapshots/internal/kernel"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateManagedConfigDiff_NewFile_GeneratesTemplate(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	// Create test snapshots
	now := time.Now()
	snapshots := []*btrfs.Snapshot{
		{
			Subvolume: &btrfs.Subvolume{
				ID:   101,
				Path: "/.snapshots/101/snapshot",
			},
			SnapshotTime: now.Add(-1 * time.Hour),
		},
		{
			Subvolume: &btrfs.Subvolume{
				ID:   100,
				Path: "/.snapshots/100/snapshot",
			},
			SnapshotTime: now.Add(-2 * time.Hour),
		},
	}

	// Create test source entries (these would normally come from multiple refind_linux.conf entries)
	sourceEntries := []*MenuEntry{
		{
			Title:   "Boot with standard options",
			Options: "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid",
		},
	}

	rootFS := &btrfs.Filesystem{
		UUID: "test-uuid",
		Subvolume: &btrfs.Subvolume{
			Path: "@",
		},
	}

	// Generate config for a new file (file doesn't exist)
	diff, err := generator.GenerateManagedConfigDiff(sourceEntries, snapshots, rootFS, "/nonexistent/path/refind-btrfs-snapshots.conf")
	require.NoError(t, err)
	require.NotNil(t, diff)

	content := diff.Modified

	// Verify header
	assert.Contains(t, content, "# WARNING - Submenu options will be overwritten automatically,")
	assert.Contains(t, content, "# but menuentry attributes will be maintained.")

	// Should contain template with disabled directive
	assert.Contains(t, content, "# TEMPLATE ENTRY - Customize this example")
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")
	assert.Contains(t, content, "    disabled")
	assert.Contains(t, content, "    icon     /EFI/refind/icons/os_arch.png")
	assert.Contains(t, content, "    loader   /boot/vmlinuz-linux")
	assert.Contains(t, content, "    initrd   /boot/initramfs-linux.img")
	assert.Contains(t, content, "# INSTRUCTIONS:")
	assert.Contains(t, content, "# 1. Remove or comment out the 'disabled' line above")

	// Should use options from source entry
	assert.Contains(t, content, "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid")

	// Should contain example submenus
	assert.Contains(t, content, "    submenuentry \"Arch Linux (")
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/101/snapshot")

	// Should be marked as a new file
	assert.True(t, diff.IsNew)
}

func TestGenerateManagedConfigDiff_ExistingFile_PreservesCustomizations(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	// Create test snapshots
	now := time.Now()
	snapshots := []*btrfs.Snapshot{
		{
			Subvolume: &btrfs.Subvolume{
				ID:   101,
				Path: "/.snapshots/101/snapshot",
			},
			SnapshotTime: now.Add(-1 * time.Hour),
		},
	}

	sourceEntries := []*MenuEntry{
		{
			Title:   "Boot with standard options",
			Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
		},
	}

	rootFS := &btrfs.Filesystem{
		UUID: "test-uuid",
		Subvolume: &btrfs.Subvolume{
			Path: "@",
		},
	}

	// Create a temporary file with existing content
	tmpDir := t.TempDir()
	configPath := filepath.Join(tmpDir, "refind-btrfs-snapshots.conf")

	existingContent := `# Generated by refind-btrfs-snapshots
# WARNING - Submenu options will be overwritten automatically,
# but menuentry attributes will be maintained.

menuentry "Arch Linux" {
    icon /EFI/refind/icons/custom_arch.png
    loader /boot/vmlinuz-linux
    initrd /boot/initramfs-linux.img
    options quiet custom_param=1 rw rootflags=subvol=@ root=UUID=test-uuid
}

menuentry "Arch Linux LTS" {
    icon /EFI/refind/icons/os_arch_lts.png
    loader /boot/vmlinuz-lts
    initrd /boot/initramfs-lts.img
    options quiet rw rootflags=subvol=@ root=UUID=test-uuid
}`

	err := os.WriteFile(configPath, []byte(existingContent), 0644)
	require.NoError(t, err)

	// Generate config for existing file
	diff, err := generator.GenerateManagedConfigDiff(sourceEntries, snapshots, rootFS, configPath)
	require.NoError(t, err)
	require.NotNil(t, diff)

	content := diff.Modified

	// Should preserve both existing entries
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")
	assert.Contains(t, content, "menuentry \"Arch Linux LTS\" {")

	// Should preserve custom attributes
	assert.Contains(t, content, "icon /EFI/refind/icons/custom_arch.png")
	assert.Contains(t, content, "icon /EFI/refind/icons/os_arch_lts.png")
	assert.Contains(t, content, "loader /boot/vmlinuz-linux")
	assert.Contains(t, content, "loader /boot/vmlinuz-lts")
	assert.Contains(t, content, "custom_param=1")

	// Should add snapshot submenus to both entries
	assert.Contains(t, content, "submenuentry \"Arch Linux (")
	assert.Contains(t, content, "submenuentry \"Arch Linux LTS (")
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/101/snapshot")

	// Should not be marked as a new file
	assert.False(t, diff.IsNew)
}

func TestGenerateMenuTitle(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	tests := []struct {
		name          string
		groupKey      string
		templateEntry *MenuEntry
		expected      string
	}{
		{
			name:     "vmlinuz-linux_loader",
			groupKey: "vmlinuz-linux",
			templateEntry: &MenuEntry{
				Loader: "/boot/vmlinuz-linux",
			},
			expected: "Arch Linux",
		},
		{
			name:     "vmlinuz-lts_loader",
			groupKey: "vmlinuz-lts",
			templateEntry: &MenuEntry{
				Loader: "/boot/vmlinuz-lts",
			},
			expected: "Arch Linux LTS",
		},
		{
			name:     "bzImage_loader",
			groupKey: "bzImage",
			templateEntry: &MenuEntry{
				Loader: "/boot/bzImage",
			},
			expected: "Linux",
		},
		{
			name:     "existing_base_name",
			groupKey: "Custom Linux",
			templateEntry: &MenuEntry{
				Loader: "/boot/vmlinuz-linux",
			},
			expected: "Custom Linux",
		},
		{
			name:     "fallback_to_title",
			groupKey: "",
			templateEntry: &MenuEntry{
				Title:  "Fallback Title",
				Loader: "",
			},
			expected: "Fallback Title",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.generateMenuTitle(tt.groupKey, tt.templateEntry)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestExtractBaseName(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	tests := []struct {
		name     string
		title    string
		expected string
	}{
		{
			name:     "title_with_timestamp",
			title:    "Boot with standard options (2025-06-12_07-00-18)",
			expected: "Boot with standard options",
		},
		{
			name:     "title_without_timestamp",
			title:    "Boot with standard options",
			expected: "Boot with standard options",
		},
		{
			name:     "title_with_spaces_and_timestamp",
			title:    "Arch Linux LTS Kernel (2024-01-15_10-30-00)",
			expected: "Arch Linux LTS Kernel",
		},
		{
			name:     "empty_title",
			title:    "",
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.extractBaseName(tt.title)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGroupEntriesByBase(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	entries := []*MenuEntry{
		{Title: "Boot with standard options (2025-06-12_07-00-18)"},
		{Title: "Boot with standard options (2025-06-12_06-00-13)"},
		{Title: "Boot to single-user mode (2025-06-12_07-00-18)"},
		{Title: "Custom Entry"},
	}

	groups := generator.groupEntriesByBase(entries)

	// Should have 3 groups
	assert.Len(t, groups, 3)

	// Check "Boot with standard options" group
	assert.Len(t, groups["Boot with standard options"], 2)

	// Check "Boot to single-user mode" group
	assert.Len(t, groups["Boot to single-user mode"], 1)

	// Check "Custom Entry" group
	assert.Len(t, groups["Custom Entry"], 1)
}

func TestParseExistingManagedConfig(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	existingConfig := `# Generated by refind-btrfs-snapshots
# WARNING - Submenu options will be overwritten automatically,
# but menuentry attributes will be maintained.

menuentry "Arch Linux" {
    icon /EFI/refind/icons/os_arch.png
    loader /boot/vmlinuz-linux
    initrd /boot/initramfs-linux.img
    options quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid
    submenuentry "Arch Linux (2025-06-12_05-00-03)" {
        options quiet rw rootflags=subvol=@/.snapshots/375/snapshot root=UUID=test-uuid
    }
}

menuentry "Custom Entry" {
    icon /EFI/refind/icons/custom.png
    volume LABEL=CUSTOM
    loader /custom/kernel
    options custom-options
}`

	entries := generator.parseExistingManagedConfig(existingConfig)

	// Should have parsed 2 entries
	assert.Len(t, entries, 2)

	// Check "Arch Linux" entry
	archEntry, exists := entries["Arch Linux"]
	require.True(t, exists)
	assert.Equal(t, "Arch Linux", archEntry.Title)
	assert.Equal(t, "/EFI/refind/icons/os_arch.png", archEntry.Icon)
	assert.Equal(t, "/boot/vmlinuz-linux", archEntry.Loader)
	assert.Equal(t, []string{"/boot/initramfs-linux.img"}, archEntry.Initrd)
	assert.Equal(t, "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid", archEntry.Options)

	// Check "Custom Entry" entry
	customEntry, exists := entries["Custom Entry"]
	require.True(t, exists)
	assert.Equal(t, "Custom Entry", customEntry.Title)
	assert.Equal(t, "/EFI/refind/icons/custom.png", customEntry.Icon)
	assert.Equal(t, "LABEL=CUSTOM", customEntry.Volume)
	assert.Equal(t, "/custom/kernel", customEntry.Loader)
	assert.Equal(t, "custom-options", customEntry.Options)
}

func TestMergeCustomizations(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	template := &MenuEntry{
		Title:   "Template",
		Loader:  "/boot/vmlinuz-linux",
		Options: "template-options",
	}

	existing := &MenuEntry{
		Title:   "Custom Title",
		Icon:    "/custom/icon.png",
		Volume:  "LABEL=CUSTOM",
		Loader:  "/custom/loader",
		Initrd:  []string{"/custom/initrd"},
		Options: "custom-options",
	}

	merged := generator.mergeCustomizations(template, existing)

	// Should preserve customizations from existing
	assert.Equal(t, "Template", merged.Title) // Title should remain from template
	assert.Equal(t, "/custom/icon.png", merged.Icon)
	assert.Equal(t, "LABEL=CUSTOM", merged.Volume)
	assert.Equal(t, "/custom/loader", merged.Loader)
	assert.Equal(t, []string{"/custom/initrd"}, merged.Initrd)
	assert.Equal(t, "custom-options", merged.Options)

	// Should have empty submenues (they get regenerated)
	assert.Empty(t, merged.Submenues)
}

func TestGenerateSingleMenuEntry(t *testing.T) {
	// Set up viper defaults for the test
	viper.SetDefault("advanced.naming.menu_format", "2006-01-02T15:04:05Z")
	viper.SetDefault("display.local_time", false)

	generator := NewGenerator("/boot/efi")

	templateEntry := &MenuEntry{
		Icon:    "/EFI/refind/icons/os_arch.png",
		Loader:  "/boot/vmlinuz-linux",
		Initrd:  []string{"/boot/initramfs-linux.img"},
		Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
	}

	snapshots := []*btrfs.Snapshot{
		{
			Subvolume: &btrfs.Subvolume{
				ID:   101,
				Path: "/.snapshots/101/snapshot",
			},
			SnapshotTime: time.Date(2025, 6, 12, 7, 0, 18, 0, time.UTC),
		},
	}

	rootFS := &btrfs.Filesystem{
		UUID: "test-uuid",
	}

	content := generator.generateSingleMenuEntry("Arch Linux", templateEntry, snapshots, rootFS)

	// Should contain menuentry
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")

	// Should contain all template attributes
	assert.Contains(t, content, "    icon /EFI/refind/icons/os_arch.png")
	assert.Contains(t, content, "    loader /boot/vmlinuz-linux")
	assert.Contains(t, content, "    initrd /boot/initramfs-linux.img")
	assert.Contains(t, content, "    options quiet rw rootflags=subvol=@ root=UUID=test-uuid")

	// Should contain submenu for snapshot
	assert.Contains(t, content, "    submenuentry \"Arch Linux (2025-06-12T07:00:18Z)\" {")
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/101/snapshot")
	assert.Contains(t, content, "subvolid=101")
	assert.Contains(t, content, "root=UUID=test-uuid")
	assert.Contains(t, content, "    }")

	// Should end with closing brace
	assert.Contains(t, content, "}")
}

func TestGenerateManagedConfigDiff_PreservesCustomizations(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	// Create a temporary file with existing content
	existingContent := `# Generated by refind-btrfs-snapshots
# WARNING - Submenu options will be overwritten automatically,
# but menuentry attributes will be maintained.

menuentry "Arch Linux" {
    icon /EFI/refind/icons/custom_arch.png
    volume LABEL=CUSTOM_ESP
    loader /boot/vmlinuz-linux
    initrd /boot/initramfs-linux.img
    options quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid custom_param=1
}`

	// Test the parsing function directly
	existingEntries := generator.parseExistingManagedConfig(existingContent)

	// Should have found the existing entry
	require.Len(t, existingEntries, 1)

	archEntry, exists := existingEntries["Arch Linux"]
	require.True(t, exists)

	// Should have preserved custom attributes
	assert.Equal(t, "/EFI/refind/icons/custom_arch.png", archEntry.Icon)
	assert.Equal(t, "LABEL=CUSTOM_ESP", archEntry.Volume)
	assert.Equal(t, []string{"/boot/initramfs-linux.img"}, archEntry.Initrd)
	assert.Equal(t, "quiet zswap.enabled=0 rw rootflags=subvol=@ root=UUID=test-uuid custom_param=1", archEntry.Options)
}

func TestUpdateOptionsForSnapshot_AvoidDoubleAt(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	snapshot := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   101,
			Path: "/.snapshots/101/snapshot", // Path without @
		},
	}

	snapshotWithAt := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   102,
			Path: "@/.snapshots/102/snapshot", // Path already with @
		},
	}

	originalOptions := "quiet rw rootflags=subvol=@ root=UUID=test-uuid"

	// Test normal case: path without @
	result1 := generator.updateOptionsForSnapshot(originalOptions, snapshot)
	assert.Contains(t, result1, "rootflags=subvol=@/.snapshots/101/snapshot")
	assert.NotContains(t, result1, "@@") // Should not have double @

	// Test case where path already has @: should not get double @
	result2 := generator.updateOptionsForSnapshot(originalOptions, snapshotWithAt)
	assert.Contains(t, result2, "rootflags=subvol=@/.snapshots/102/snapshot")
	assert.NotContains(t, result2, "@@") // Should not have double @
}

func TestParseConfig_MultipleInitrdDirectives(t *testing.T) {
	// Create a temporary directory for test files
	tmpDir := t.TempDir()

	// Create a test config with multiple initrd directives (e.g., microcode + initramfs)
	configContent := `timeout 20

menuentry "Arch Linux" {
    icon /EFI/refind/icons/os_arch.png
    loader /boot/vmlinuz-linux
    initrd /boot/intel-ucode.img
    initrd /boot/initramfs-linux.img
    options "root=UUID=test-uuid rootflags=subvol=@ rw quiet"
}

menuentry "Arch Linux LTS" {
    icon /EFI/refind/icons/os_arch.png
    loader /boot/vmlinuz-linux-lts
    initrd /boot/amd-ucode.img
    initrd /boot/initramfs-linux-lts.img
    options "root=UUID=test-uuid rootflags=subvol=@ rw quiet"
}`

	configPath := filepath.Join(tmpDir, "refind.conf")
	err := os.WriteFile(configPath, []byte(configContent), 0644)
	require.NoError(t, err)

	// Parse the config
	parser := NewParser(tmpDir)
	config, err := parser.ParseConfig(configPath)
	require.NoError(t, err)
	require.NotNil(t, config)
	require.Len(t, config.Entries, 2)

	// Check first entry has both initrd files
	archEntry := config.Entries[0]
	assert.Equal(t, "Arch Linux", archEntry.Title)
	assert.Equal(t, []string{"/boot/intel-ucode.img", "/boot/initramfs-linux.img"}, archEntry.Initrd)

	// Check second entry has both initrd files
	ltsEntry := config.Entries[1]
	assert.Equal(t, "Arch Linux LTS", ltsEntry.Title)
	assert.Equal(t, []string{"/boot/amd-ucode.img", "/boot/initramfs-linux-lts.img"}, ltsEntry.Initrd)
}

func TestGenerateSingleMenuEntry_MultipleInitrdDirectives(t *testing.T) {
	// Set up viper defaults for the test
	viper.SetDefault("advanced.naming.menu_format", "2006-01-02T15:04:05Z")
	viper.SetDefault("display.local_time", false)

	generator := NewGenerator("/boot/efi")

	templateEntry := &MenuEntry{
		Icon:    "/EFI/refind/icons/os_arch.png",
		Loader:  "/boot/vmlinuz-linux",
		Initrd:  []string{"/boot/intel-ucode.img", "/boot/initramfs-linux.img"},
		Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
	}

	snapshots := []*btrfs.Snapshot{
		{
			Subvolume: &btrfs.Subvolume{
				ID:   101,
				Path: "/.snapshots/101/snapshot",
			},
			SnapshotTime: time.Date(2025, 6, 12, 7, 0, 18, 0, time.UTC),
		},
	}

	rootFS := &btrfs.Filesystem{
		UUID: "test-uuid",
	}

	content := generator.generateSingleMenuEntry("Arch Linux", templateEntry, snapshots, rootFS)

	// Should contain menuentry
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")

	// Should contain all template attributes
	assert.Contains(t, content, "    icon /EFI/refind/icons/os_arch.png")
	assert.Contains(t, content, "    loader /boot/vmlinuz-linux")

	// Should contain both initrd directives in order
	assert.Contains(t, content, "    initrd /boot/intel-ucode.img")
	assert.Contains(t, content, "    initrd /boot/initramfs-linux.img")

	// Verify they appear in the correct order
	ucodeIndex := strings.Index(content, "initrd /boot/intel-ucode.img")
	initramfsIndex := strings.Index(content, "initrd /boot/initramfs-linux.img")
	assert.True(t, ucodeIndex < initramfsIndex, "Microcode initrd should appear before main initramfs")

	assert.Contains(t, content, "    options quiet rw rootflags=subvol=@ root=UUID=test-uuid")

	// Should contain submenu for snapshot
	assert.Contains(t, content, "    submenuentry \"Arch Linux (2025-06-12T07:00:18Z)\" {")
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/101/snapshot")
	assert.Contains(t, content, "subvolid=101")
	assert.Contains(t, content, "root=UUID=test-uuid")
	assert.Contains(t, content, "    }")

	// Should end with closing brace
	assert.Contains(t, content, "}")
}

// --- Boot Plan / Boot Mode tests for generated output ---

// TestGenerateSingleMenuEntry_BtrfsMode verifies that btrfs-mode snapshots
// generate submenu entries with volume, loader, and initrd overrides pointing
// into the snapshot's own /boot directory.
func TestGenerateSingleMenuEntry_BtrfsMode(t *testing.T) {
	viper.SetDefault("advanced.naming.menu_format", "2006-01-02T15:04:05Z")
	viper.SetDefault("display.local_time", false)

	snapshot := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   256,
			Path: "@/.snapshots/73/snapshot",
		},
		FilesystemPath: "/mnt/@/.snapshots/73/snapshot",
		SnapshotTime:   time.Date(2025, 2, 14, 10, 0, 0, 0, time.UTC),
	}

	bootPlans := []*kernel.BootPlan{
		{
			Snapshot:       snapshot,
			Mode:           kernel.BootModeBtrfs,
			SnapshotKernel: "/@/.snapshots/73/snapshot/boot/vmlinuz-linux",
			SnapshotInitrds: []string{
				"/@/.snapshots/73/snapshot/boot/intel-ucode.img",
				"/@/.snapshots/73/snapshot/boot/initramfs-linux.img",
			},
			BtrfsVolume: "ARCH_ROOT",
		},
	}

	generator := NewGeneratorWithBootPlans("/boot/efi", nil, nil, bootPlans)

	templateEntry := &MenuEntry{
		Icon:    "/EFI/refind/icons/os_arch.png",
		Loader:  "/boot/vmlinuz-linux",
		Initrd:  []string{"/boot/intel-ucode.img", "/boot/initramfs-linux.img"},
		Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
	}

	rootFS := &btrfs.Filesystem{UUID: "test-uuid"}
	content := generator.generateSingleMenuEntry("Arch Linux", templateEntry, []*btrfs.Snapshot{snapshot}, rootFS)

	// Main entry should have ESP-relative paths (the default boot entry)
	assert.Contains(t, content, "menuentry \"Arch Linux\" {")
	assert.Contains(t, content, "    loader /boot/vmlinuz-linux")

	// Submenu entry should have btrfs-mode overrides
	assert.Contains(t, content, "submenuentry \"Arch Linux (2025-02-14T10:00:00Z)\" {")
	assert.Contains(t, content, "        volume  ARCH_ROOT")
	assert.Contains(t, content, "        loader  /@/.snapshots/73/snapshot/boot/vmlinuz-linux")
	assert.Contains(t, content, "        initrd  /@/.snapshots/73/snapshot/boot/intel-ucode.img")
	assert.Contains(t, content, "        initrd  /@/.snapshots/73/snapshot/boot/initramfs-linux.img")

	// Options should still have the snapshot subvol (needed for root mount)
	assert.Contains(t, content, "rootflags=subvol=@/.snapshots/73/snapshot")
	assert.Contains(t, content, "subvolid=256")
}

// TestGenerateSingleMenuEntry_ESPModeUnchangedWithBootPlans verifies that
// ESP-mode output is byte-identical with or without boot plans present.
// This is the backward compatibility guarantee for existing users.
func TestGenerateSingleMenuEntry_ESPModeUnchangedWithBootPlans(t *testing.T) {
	viper.SetDefault("advanced.naming.menu_format", "2006-01-02T15:04:05Z")
	viper.SetDefault("display.local_time", false)

	snapshot := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   101,
			Path: "@/.snapshots/42/snapshot",
		},
		FilesystemPath: "/mnt/@/.snapshots/42/snapshot",
		SnapshotTime:   time.Date(2025, 6, 12, 7, 0, 18, 0, time.UTC),
	}

	espPlan := &kernel.BootPlan{
		Snapshot: snapshot,
		Mode:     kernel.BootModeESP,
	}

	templateEntry := &MenuEntry{
		Icon:    "/EFI/refind/icons/os_arch.png",
		Loader:  "/boot/vmlinuz-linux",
		Initrd:  []string{"/boot/initramfs-linux.img"},
		Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
	}

	rootFS := &btrfs.Filesystem{UUID: "test-uuid"}

	// Generate WITH boot plans (ESP mode plan)
	withPlans := NewGeneratorWithBootPlans("/boot/efi", nil, nil, []*kernel.BootPlan{espPlan})
	contentWith := withPlans.generateSingleMenuEntry("Arch Linux", templateEntry, []*btrfs.Snapshot{snapshot}, rootFS)

	// Generate WITHOUT boot plans (old code path, no plans at all)
	without := NewGenerator("/boot/efi")
	contentWithout := without.generateSingleMenuEntry("Arch Linux", templateEntry, []*btrfs.Snapshot{snapshot}, rootFS)

	// Must be byte-identical — this is the key backward compat assertion
	assert.Equal(t, contentWithout, contentWith,
		"ESP-mode output must be identical with or without boot plans")
}

// TestGenerateSingleMenuEntry_MixedModeSnapshots verifies correct output when
// a menu entry has both ESP-mode and btrfs-mode snapshots as submenus —
// simulating the ESP-to-btrfs transition scenario.
func TestGenerateSingleMenuEntry_MixedModeSnapshots(t *testing.T) {
	viper.SetDefault("advanced.naming.menu_format", "2006-01-02T15:04:05Z")
	viper.SetDefault("display.local_time", false)

	espSnap := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   101,
			Path: "@/.snapshots/42/snapshot",
		},
		FilesystemPath: "/mnt/@/.snapshots/42/snapshot",
		SnapshotTime:   time.Date(2025, 1, 15, 12, 0, 0, 0, time.UTC),
	}

	btrfsSnap := &btrfs.Snapshot{
		Subvolume: &btrfs.Subvolume{
			ID:   256,
			Path: "@/.snapshots/73/snapshot",
		},
		FilesystemPath: "/mnt/@/.snapshots/73/snapshot",
		SnapshotTime:   time.Date(2025, 2, 14, 10, 0, 0, 0, time.UTC),
	}

	bootPlans := []*kernel.BootPlan{
		{Snapshot: espSnap, Mode: kernel.BootModeESP},
		{
			Snapshot:        btrfsSnap,
			Mode:            kernel.BootModeBtrfs,
			SnapshotKernel:  "/@/.snapshots/73/snapshot/boot/vmlinuz-linux",
			SnapshotInitrds: []string{"/@/.snapshots/73/snapshot/boot/initramfs-linux.img"},
			BtrfsVolume:     "ARCH_ROOT",
		},
	}

	generator := NewGeneratorWithBootPlans("/boot/efi", nil, nil, bootPlans)

	templateEntry := &MenuEntry{
		Loader:  "/boot/vmlinuz-linux",
		Initrd:  []string{"/boot/initramfs-linux.img"},
		Options: "quiet rw rootflags=subvol=@ root=UUID=test-uuid",
	}

	rootFS := &btrfs.Filesystem{UUID: "test-uuid"}
	content := generator.generateSingleMenuEntry("Arch Linux", templateEntry,
		[]*btrfs.Snapshot{espSnap, btrfsSnap}, rootFS)

	// ESP submenu: must NOT have volume/loader/initrd overrides
	espSubmenu := "submenuentry \"Arch Linux (2025-01-15T12:00:00Z)\""
	assert.Contains(t, content, espSubmenu)
	espIdx := strings.Index(content, espSubmenu)
	espEnd := strings.Index(content[espIdx:], "    }")
	espSection := content[espIdx : espIdx+espEnd]
	assert.NotContains(t, espSection, "volume  ", "ESP submenu must not have volume override")
	assert.NotContains(t, espSection, "loader  /@/", "ESP submenu must not have btrfs loader")
	assert.Contains(t, espSection, "rootflags=subvol=@/.snapshots/42/snapshot")

	// Btrfs submenu: MUST have volume/loader/initrd overrides
	btrfsSubmenu := "submenuentry \"Arch Linux (2025-02-14T10:00:00Z)\""
	assert.Contains(t, content, btrfsSubmenu)
	btrfsIdx := strings.Index(content, btrfsSubmenu)
	btrfsEnd := strings.Index(content[btrfsIdx:], "    }")
	btrfsSection := content[btrfsIdx : btrfsIdx+btrfsEnd]
	assert.Contains(t, btrfsSection, "volume  ARCH_ROOT")
	assert.Contains(t, btrfsSection, "loader  /@/.snapshots/73/snapshot/boot/vmlinuz-linux")
	assert.Contains(t, btrfsSection, "initrd  /@/.snapshots/73/snapshot/boot/initramfs-linux.img")
	assert.Contains(t, btrfsSection, "rootflags=subvol=@/.snapshots/73/snapshot")
}

func TestIsLegacyGeneratedSnapshotEntry(t *testing.T) {
	generator := NewGenerator("/boot/efi")

	tests := []struct {
		name     string
		line     string
		expected bool
	}{
		// Should match: generated entries with timestamp in parens
		{
			"snapshot_with_date",
			`"Boot default (2026-02-14 12:30:00)" "root=UUID=abc rootflags=subvol=@/.snapshots/42/snapshot"`,
			true,
		},
		{
			"snapshot_short_date",
			`"Arch Linux (2026-02-14)" "root=UUID=abc rootflags=subvol=@/.snapshots/1/snapshot"`,
			true,
		},
		// Should NOT match: normal user entries
		{
			"normal_boot_entry",
			`"Boot default" "root=UUID=abc rootflags=subvol=@"`,
			false,
		},
		{
			"no_parentheses",
			`"Arch Linux" "root=UUID=abc rootflags=subvol=@"`,
			false,
		},
		{
			"empty_line",
			"",
			false,
		},
		{
			"comment_line",
			`# This is a comment`,
			false,
		},
		{
			"parens_without_timestamp",
			`"Boot (recovery mode)" "root=UUID=abc single"`,
			false,
		},
		{
			"parens_with_year_but_no_full_date",
			`"Kernel (version 6.19.0-2024)" "root=UUID=abc"`,
			false, // regex requires year + two 2-digit groups (month/day-like)
		},
		{
			"parens_with_full_date_like_pattern",
			`"Arch Linux (2026-02-14 12:30)" "root=UUID=abc rootflags=subvol=@/.snapshots/99/snapshot"`,
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, generator.isLegacyGeneratedSnapshotEntry(tt.line))
		})
	}
}
